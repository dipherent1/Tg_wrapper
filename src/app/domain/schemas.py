# src/app/domain/schemas.py

import uuid
from datetime import datetime
from pydantic import BaseModel, ConfigDict
from typing import List, Optional

# Import the status enum from the models to ensure consistency
from .models import Status


# --- Base Schemas ---
# These contain the common fields shared between creation and reading.

class TagBase(BaseModel):
    name: str

class ChannelBase(BaseModel):
    telegram_id: int
    name: Optional[str] = None
    username: Optional[str] = None

class UserBase(BaseModel):
    telegram_id: int
    full_name: str
    username: Optional[str] = None

class SubscriptionBase(BaseModel):
    query_text: str

class MessageBase(BaseModel):
    telegram_message_id: int
    content: Optional[str] = None
    sent_at: datetime


# --- Create Schemas ---
# These are used as input when creating new objects. They should not contain
# server-generated fields like id, created_at, etc.

class TagCreate(TagBase):
    pass

class ChannelCreate(ChannelBase):
    pass

class UserCreate(UserBase):
    pass

class SubscriptionCreate(SubscriptionBase):
    pass

class MessageCreate(MessageBase):
    # We need to know which channel to link this message to on creation.
    channel_id: uuid.UUID


# --- Read Schemas (The main schemas for API output) ---
# These include all fields, including the ones generated by the database.
# They are configured to work with ORM objects.

class Tag(TagBase):
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID

class Channel(ChannelBase):
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    status: Status
    created_at: datetime
    updated_at: Optional[datetime] = None
    clickable_link: Optional[str] = None
    tags: List[Tag] = []

class Message(MessageBase):
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    channel_id: uuid.UUID
    created_at: datetime
    clickable_link: str

# To prevent circular dependency issues between User and Subscription,
# we define the schemas that will be nested first.

class SubscriptionForUser(SubscriptionBase):
    """A minimal Subscription schema to be nested inside the User schema."""
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    status: Status

class UserForSubscription(UserBase):
    """A minimal User schema to be nested inside the Subscription schema."""
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID

# Now, define the full "Read" schemas for User and Subscription

class User(UserBase):
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    status: Status
    created_at: datetime
    updated_at: Optional[datetime] = None
    subscriptions: List[SubscriptionForUser] = []

class Subscription(SubscriptionBase):
    model_config = ConfigDict(from_attributes=True)
    id: uuid.UUID
    status: Status
    user_id: uuid.UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    user: UserForSubscription