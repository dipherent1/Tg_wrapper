# src/app/domain/schemas.py

import uuid
import datetime
from pydantic import BaseModel, ConfigDict
from typing import List, Optional

from .models import Status, ChatType # Import our custom Status enum

# --- Base Schemas (for creation) ---

class UserCreate(BaseModel):
    telegram_id: int
    full_name: str
    username: Optional[str] = None

class TagCreate(BaseModel):
    name: str

class ChannelCreate(BaseModel):
    telegram_id: int
    name: Optional[str] = None
    username: Optional[str] = None
    type: Optional[ChatType] = None

class SubscriptionCreate(BaseModel):
    user_id: uuid.UUID
    query_text: str

class MessageCreate(BaseModel):
    telegram_message_id: int
    content: Optional[str] = None
    sent_at: datetime.datetime


# --- Full Schemas (for reading from DB) ---
# These include fields that are generated by the database, like id, created_at, etc.

class Tag(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    
    id: uuid.UUID
    name: str

class Channel(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: uuid.UUID
    telegram_id: int
    name: Optional[str] = None
    username: Optional[str] = None
    status: Status
    clickable_link: Optional[str] # From our @property
    tags: List[Tag] = []
    type: Optional[ChatType] = None

class User(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: uuid.UUID
    telegram_id: int
    full_name: str
    username: Optional[str] = None
    status: Status
    created_at: datetime.datetime

class Subscription(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: uuid.UUID
    user_id: uuid.UUID
    query_text: str
    status: Status
    created_at: datetime.datetime

class Message(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: uuid.UUID
    telegram_message_id: int
    content: Optional[str] = None
    sent_at: datetime.datetime
    clickable_link: str # From our @property